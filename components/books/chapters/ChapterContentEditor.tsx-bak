'use client'

import * as React from 'react'
import { useEffect, useState } from 'react'
import { useFormContext, Controller } from 'react-hook-form'
import dynamic from 'next/dynamic'
import { cn } from '@/lib/services/utils'
import type { Editor } from '@tiptap/react'

// âœ… Import SimpleEditor (default export) with SSR disabled
const SimpleEditor = dynamic(
  () => import('@/components/tiptap-templates/simple/simple-editor'),
  { 
    ssr: false,
    loading: () => <EditorLoading />
  }
);

function EditorLoading({ className }: { className?: string }) {
  return (
    <div className={cn("flex items-center justify-center min-h-[300px] border rounded-lg bg-muted/20", className)}>
      <div className="animate-spin h-8 w-8 text-muted-foreground" />
    </div>
  )
}

export interface ChapterContentEditorProps {
  name: string;
  className?: string;
  initialContent?: string;
  disabled?: boolean;
  onChange?: (content: string) => void;
  editorProps?: {
    attributes?: Record<string, string>;
    handleDOMEvents?: Record<string, (props: { editor: Editor; event: Event }) => boolean | void>;
  };
  placeholder?: string;
}

function ChapterContentEditorComponent({
  name,
  className,
  initialContent = '',
  disabled = false,
  onChange: externalOnChange,
  editorProps = {},
  placeholder = 'Start writing your content here...',
}: ChapterContentEditorProps) {
  const { control, formState: { errors } } = useFormContext();
  const error = errors[name]?.message as string | undefined;

  return (
    <div className="w-full">
      <div className={cn("rounded-lg border", className, disabled && 'opacity-50')}>
        <Controller
          name={name}
          control={control}
          defaultValue={initialContent}
          render={({ field: { onChange, value } }) => (
            <div className="relative">
              <SimpleEditor
                content={value || ''}
                onChange={(content: string) => {
                  if (content !== value) {
                    onChange(content);
                    externalOnChange?.(content);
                  }
                }}
                className={cn({
                  'opacity-75': disabled,
                  'border-destructive': error,
                })}
                editorProps={{
                  ...editorProps,
                  attributes: {
                    ...editorProps.attributes,
                    class: cn(
                      "prose dark:prose-invert prose-sm sm:prose-base max-w-none p-4 focus:outline-none min-h-[300px] w-full",
                      disabled ? 'cursor-not-allowed bg-muted/50' : 'bg-background',
                      error && 'border border-destructive rounded',
                      editorProps.attributes?.class
                    ),
                    'data-placeholder': placeholder,
                  },
                }}
                editable={!disabled}
              />
              {!value && !disabled && (
                <div className="absolute top-4 left-4 pointer-events-none text-muted-foreground">
                  {placeholder}
                </div>
              )}
            </div>
          )}
        />
        {error && <p className="mt-1 text-sm text-destructive px-4">{error}</p>}
      </div>
    </div>
  );
}

export function ChapterContentEditor({ className, ...props }: ChapterContentEditorProps) {
  const [isMounted, setIsMounted] = useState(false);

  useEffect(() => setIsMounted(true), []);

  if (!isMounted) {
    return <EditorLoading className={className} />;
  }

  return <ChapterContentEditorComponent className={className} {...props} />;
}

export default ChapterContentEditor;
