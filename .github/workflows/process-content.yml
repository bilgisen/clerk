name: Process and Publish E-Book

on:
  workflow_dispatch:
    inputs:
      content_id:
        description: 'Content ID for the book'
        required: true
        type: string
      format:
        description: 'Output format (epub, mobi, pdf, html, docx)'
        required: true
        default: 'epub'
        type: string
      metadata:
        description: 'Additional metadata as JSON string'
        required: false
        default: '{}'
        type: string

env:
  # Default configuration
  NODE_ENV: production
  
  # Clerk JWT configuration - Match Clerk's configuration
  JWT_ISSUER: 'clerk.clerko.v1'
  JWT_AUDIENCE: 'https://api.clerko.com'
  
  # Clerk template name and key ID
  CLERK_KEY_ID: 'jtmp_310Eh03rhbpy3wXWHcIaNkwwTpj'
  JWT_TEMPLATE: 'matbuapp'
  
  # Repository information
  GITHUB_REPO_OWNER: bilgisen
  GITHUB_REPO_NAME: clerk
  
  # Timeouts in seconds
  DOWNLOAD_TIMEOUT: 300
  BUILD_TIMEOUT: 600

jobs:
  build-epub:
    name: Build EPUB
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install dependencies
        run: |
          # Ensure we're using the correct Node.js version
          node --version
          npm --version
          
          # Install dependencies
          npm install --legacy-peer-deps
          npm install jose@^4.14.0

      - name: Install system tools
        run: |
          echo "üîÑ Updating package lists..."
          sudo apt-get update -qq
          
          echo "üì¶ Installing required tools..."
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
            coreutils \
            pandoc \
            texlive-xetex \
            texlive-fonts-recommended \
            texlive-latex-recommended \
            jq \
            wget \
            parallel \
            curl \
            ca-certificates \
            gnupg \
            software-properties-common
            
          # Verify coreutils is installed and base64 is available
          if ! command -v base64 &> /dev/null; then
            echo "::warning::base64 command not found in PATH, checking /usr/bin/"
            if [ -x "/usr/bin/base64" ]; then
              echo "Found base64 in /usr/bin/, adding to PATH"
              echo "/usr/bin" >> $GITHUB_PATH
              export PATH="/usr/bin:$PATH"
            else
              echo "::error::base64 command not found after coreutils installation"
              exit 1
            fi
          fi
          
          # Verify base64 works
          if ! echo "test" | base64 > /dev/null 2>&1; then
            echo "::error::base64 command is not working as expected"
            exit 1
          fi
          
          # Clean up to reduce image size
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*

      - name: Set up security files
        run: |
          echo "üîê Setting up security files..."
          # Create .env file for the application
          echo "NEXT_PUBLIC_APP_URL=https://matbu.vercel.app" > .env
          echo "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=$NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY" >> .env
          
          # Decode private key if provided
          if [ -n "$PRIVATE_KEY_B64" ]; then
            echo "üîë Decoding private key..."
            echo "$PRIVATE_KEY_B64" | base64 --decode > private.pem
            chmod 600 private.pem
          else
            echo "‚ö†Ô∏è No private key provided, some features may be limited"
          fi
          
          # Set secure permissions
          chmod -R 700 .

      - name: Generate JWT Token
        id: generate-token
        timeout-minutes: 5
        env:
          # Required for JWT generation
          PRIVATE_KEY_B64: ${{ secrets.PRIVATE_KEY_B64 }}
          JWT_ISSUER: ${{ env.JWT_ISSUER || 'clerk.clerko.v1' }}
          JWT_AUDIENCE: ${{ env.JWT_AUDIENCE || 'https://api.clerko.com' }}
          CLERK_KEY_ID: ${{ env.CLERK_KEY_ID }}
          JWT_TEMPLATE: ${{ env.JWT_TEMPLATE || 'matbuapp' }}
          NEXT_PUBLIC_APP_URL: 'https://matbu.vercel.app'
          
          # Additional context for debugging
          NODE_OPTIONS: --no-warnings
          NODE_DEBUG: jose
          DEBUG: '*'
          
          # GitHub context
          GITHUB_WORKFLOW: ${{ github.workflow }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_ACTION: ${{ github.action }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -e
          echo "üîë Generating JWT token..."
          
          # Create a temporary directory for our files
          TEMP_DIR=$(mktemp -d)
          trap 'rm -rf "$TEMP_DIR"' EXIT
          
          # Create private key file from base64 using Node.js
          node -e "
            const fs = require('fs');
            const privateKeyPem = Buffer.from(process.env.PRIVATE_KEY_B64, 'base64').toString('utf-8');
            fs.writeFileSync('$TEMP_DIR/private.pem', privateKeyPem);
            fs.chmodSync('$TEMP_DIR/private.pem', 0o600);
            console.log('‚úÖ Private key file created');
          "
          
          # Install required dependencies
          echo "üì¶ Installing dependencies..."
          npm install jose@^4.14.0
          
          # Debug: Print environment variables
          echo "\n=== Environment Variables ==="
          echo "JWT_ISSUER: $JWT_ISSUER"
          echo "JWT_AUDIENCE: $JWT_AUDIENCE"
          echo "CLERK_KEY_ID: $CLERK_KEY_ID"
          echo "JWT_TEMPLATE: $JWT_TEMPLATE"
          
          # Generate the token with the private key and required env vars
          echo "\nüî® Generating JWT token..."
          
          # Run the script and capture all output
          set +e
          JWT_OUTPUT=$(PRIVATE_KEY_PATH="$TEMP_DIR/private.pem" \
            JWT_ISSUER="$JWT_ISSUER" \
            JWT_AUDIENCE="$JWT_AUDIENCE" \
            CLERK_KEY_ID="$CLERK_KEY_ID" \
            JWT_TEMPLATE="$JWT_TEMPLATE" \
            NODE_DEBUG=* \
            DEBUG=* \
            node scripts/generate-jwt.mjs 2>&1)
          
          # Capture the exit status
          JWT_EXIT_CODE=$?
          set -e
          
          # Save the full output to a file for debugging
          echo "$JWT_OUTPUT" > jwt-debug.log
          
          # Print the output (limited to avoid overwhelming logs)
          echo "=== JWT Generation Output (last 50 lines) ==="
          echo "$JWT_OUTPUT" | tail -n 50
          
          # Check if the command failed
          if [ $JWT_EXIT_CODE -ne 0 ]; then
            echo "::error::Failed to generate JWT token (exit code: $JWT_EXIT_CODE)"
            echo "::group::Full JWT Generation Output"
            echo "$JWT_OUTPUT"
            echo "::endgroup::"
            
            # Try to extract just the error message if possible
            ERROR_MSG=$(echo "$JWT_OUTPUT" | grep -i -E 'error|exception|failed' | tail -n 5 || true)
            if [ -n "$ERROR_MSG" ]; then
              echo "::error::Error details: $ERROR_MSG"
            fi
            
            exit 1
          fi
          
          # Extract the token (should be the last line of output)
          JWT_TOKEN=$(echo "$JWT_OUTPUT" | tail -n 1)
          
          # Verify we got a token
          if [ -z "$JWT_TOKEN" ] || [ $(echo "$JWT_TOKEN" | wc -c) -lt 100 ]; then
            echo "::error::Invalid or empty JWT token received"
            echo "Token: '$JWT_TOKEN'"
            exit 1
          fi
          
          # Verify the token is not empty and looks like a JWT
          if [ -z "$JWT_TOKEN" ] || [ $(echo "$JWT_TOKEN" | grep -o '\\.' | wc -l) -lt 2 ]; then
            echo "::error::Generated JWT token is invalid or empty"
            echo "Token output: $JWT_TOKEN"
            exit 1
          fi
          
          # Set the JWT token and header in environment variables
          echo "JWT_TOKEN=$JWT_TOKEN" >> $GITHUB_ENV
          echo "JWT_HEADER=Bearer $JWT_TOKEN" >> $GITHUB_ENV
          
          # Debug: Print token info using Node.js for base64 decoding
          echo "\n=== JWT Token Info ==="
          echo "Token length: ${#JWT_TOKEN} characters"
          
          # Decode and display token payload using Node.js
          node -e "
            try {
              const [header, payload] = process.env.JWT_TOKEN.split('.');
              const decodedHeader = JSON.parse(Buffer.from(header, 'base64').toString('utf-8'));
              const decodedPayload = JSON.parse(Buffer.from(payload, 'base64').toString('utf-8'));
              
              console.log('\nüîê JWT Header:');
              console.log(JSON.stringify(decodedHeader, null, 2));
              
              console.log('\nüîê JWT Payload:');
              console.log(JSON.stringify(decodedPayload, null, 2));
              
              console.log('\n‚úÖ Token generated successfully');
            } catch (error) {
              console.error('Error decoding token:', error.message);
              console.log('\nüîê JWT Token (raw):', process.env.JWT_TOKEN);
              process.exit(1);
            }
          "
          
          echo "\n‚úÖ JWT token generated and environment variables set"

      - name: Debug JWT Token
        run: |
          echo "üîë JWT Token Debug:"
          echo "Token length: ${#JWT_TOKEN}"
          echo "Header: ${JWT_HEADER:0:20}..."
          echo "Content ID: ${{ github.event.inputs.content_id }}"
          echo "Base URL: https://matbu.vercel.app"
          echo "Repository: ${{ env.GITHUB_REPO_OWNER }}/${{ env.GITHUB_REPO_NAME }}"
          
          # Print the first part of the token for debugging (header)
          if [ -n "$JWT_TOKEN" ]; then
            echo "\nToken Header (decoded):"
            echo "$JWT_TOKEN" | cut -d'.' -f1 | base64 -d 2>/dev/null || echo "Failed to decode token header"
            
            echo "\nToken Payload (decoded):"
            echo "$JWT_TOKEN" | cut -d'.' -f2 | base64 -d 2>/dev/null || echo "Failed to decode token payload"
          else
            echo "\n‚ùå JWT_TOKEN is empty"
          fi

      - name: Fetch Book Content
        id: fetch-book
        timeout-minutes: 30
        env:
          CONTENT_ID: ${{ github.event.inputs.content_id }}
          BASE_URL: 'https://matbu.vercel.app'
          GITHUB_REPO_OWNER: ${{ env.GITHUB_REPO_OWNER }}
          GITHUB_REPO_NAME: ${{ env.GITHUB_REPO_NAME }}
          GITHUB_REF: ${{ github.ref }}
          JWT_HEADER: ${{ env.JWT_HEADER }}
          JWT_TOKEN: ${{ env.JWT_TOKEN }}
          DOWNLOAD_TIMEOUT: ${{ env.DOWNLOAD_TIMEOUT }}
          # Add verbose logging
          CURL_VERBOSE: "1"
          DEBUG: "*"
        run: |
          set -e
          echo "üìö Starting book content fetch for ID: $CONTENT_ID"
          
          # Debug environment variables (excluding sensitive data)
          echo "[INFO] üîß Environment variables:"
          printenv | grep -v -E 'SECRET|TOKEN|PASSWORD|KEY' | sort
          
          # Validate JWT token
          if [ -z "$JWT_TOKEN" ]; then
            echo "::error::JWT_TOKEN is empty"
            exit 1
          fi
          
          # Create output directory
          mkdir -p ./book-content
          
          # Make the script executable
          chmod +x scripts/fetch-book.sh
          
          # Debug: Print token info
          echo "[DEBUG] üîë JWT Token Info:"
          echo "- Token length: ${#JWT_TOKEN} characters"
          if command -v jq &> /dev/null; then
            echo -n "- Token payload: "
            echo "$JWT_TOKEN" | cut -d'.' -f2 | base64 -d 2>/dev/null | jq -c '{iss, aud, sub, iat, exp}' || echo "Failed to decode JWT payload"
          fi
          
          # Debug: Make a test request to the API
          echo "[DEBUG] üß™ Testing API access..."
          curl -v -s -f \
            -H "Accept: application/json" \
            -H "Authorization: Bearer $JWT_TOKEN" \
            "$BASE_URL/api/books/by-id/$CONTENT_ID/payload" \
            -o /dev/null \
            -w "\nResponse Code: %{http_code}\n" \
            --max-time 30 || true
          
          # Set executable permissions and run the fetch script with timeout
          echo "[INFO] üöÄ Starting fetch-book.sh..."
          chmod +x ./scripts/fetch-book.sh
          
          # Execute the script with the token
          if ! timeout $DOWNLOAD_TIMEOUT ./scripts/fetch-book.sh; then
            echo "::error::Book content fetch failed"
            
            # Check for any error logs
            if [ -f "./curl-debug.log" ]; then
              echo "=== cURL Debug Log ==="
              cat ./curl-debug.log
            fi
            
            if [ -f "./headers.txt" ]; then
              echo "=== Response Headers ==="
              cat ./headers.txt
            fi
            
            exit 1
          fi
          
          echo "‚úÖ Successfully fetched book content"
          
          # Extract metadata from the downloaded content
          if [ -f "./book-content/payload.json" ]; then
            echo "üìã Extracting metadata from payload..."
            jq '{ 
              title: .book.title, 
              author: .book.author, 
              language: .book.language,
              generateToc: (.options.generate_toc // true),
              tocDepth: (.options.toc_depth // 2),
              includeImprint: (.options.include_imprint // true)
            }' ./book-content/payload.json > ./book-metadata.json
            
            # Set output variables
            echo "::set-output name=title::$(jq -r '.title // "Untitled"' ./book-metadata.json)"
            echo "::set-output name=author::$(jq -r '.author // "Unknown"' ./book-metadata.json)"
            echo "::set-output name=language::$(jq -r '.language // "tr"' ./book-metadata.json)
            echo "::set-output name=generate_toc::$(jq -r '.generateToc // true' ./book-metadata.json)"
            echo "::set-output name=toc_depth::$(jq -r '.tocDepth // 2' ./book-metadata.json)
          else
            echo "::warning::‚ö†Ô∏è No payload.json found, using default metadata"
            echo "::set-output name=title::Untitled"
            echo "::set-output name=author::Unknown"
            echo "::set-output name=language::tr"
            echo "::set-output name=generate_toc::true"
            echo "::set-output name=toc_depth::2"
          fi
      
      - name: Generate E-Book
        id: generate-ebook
        timeout-minutes: 30
        env:
          BUILD_TIMEOUT: ${{ env.BUILD_TIMEOUT }}
        run: |
          set -e
          echo "üìñ Starting e-book generation..."
          
          # Get metadata from previous step
          TITLE="${{ steps.fetch-book.outputs.title }}"
          AUTHOR="${{ steps.fetch-book.outputs.author }}"
          LANGUAGE="${{ steps.fetch-book.outputs.language }}"
          GENERATE_TOC="${{ steps.fetch-book.outputs.generate_toc }}"
          TOC_DEPTH="${{ steps.fetch-book.outputs.toc_depth }}"
          CONTENT_ID="${{ github.event.inputs.content_id }}"
          
          echo "üìö Book: $TITLE by $AUTHOR"
          echo "üåê Language: $LANGUAGE"
          echo "üìë TOC: $GENERATE_TOC (Depth: $TOC_DEPTH)"
          
          # Prepare output directory
          mkdir -p ./output
          
          # Build Pandoc command
          PANDOC_CMD=(
            "pandoc"
            "--from=html"
            "--to=epub3"
            "--output=./output/${CONTENT_ID}.epub"
            "--epub-chapter-level=1"
            "--metadata=title:${TITLE}"
            "--metadata=author:${AUTHOR}"
            "--metadata=language:${LANGUAGE}"
            "--metadata=identifier:${CONTENT_ID}"
          )
          
          # Add TOC if enabled
          if [ "$GENERATE_TOC" = "true" ]; then
            PANDOC_CMD+=("--toc" "--toc-depth=${TOC_DEPTH}")
          fi
          
          # Add cover image if exists
          if [ -f "./book-content/cover.jpg" ]; then
            PANDOC_CMD+=("--epub-cover-image=./book-content/cover.jpg")
          fi
          
          # Add stylesheet if exists
          if [ -f "./book-content/styles/epub.css" ]; then
            PANDOC_CMD+=("--css=./book-content/styles/epub.css")
          fi
          
          # Add all chapter files in order
          while IFS= read -r -d $'\0' file; do
            PANDOC_CMD+=("$file")
          done < <(find ./book-content -type f -name 'chapter-*.xhtml' -print0 | sort -z -V)
          
          # Add imprint if exists
          if [ -f "./book-content/imprint.xhtml" ]; then
            PANDOC_CMD+=("./book-content/imprint.xhtml")
          fi
          
          echo "üîÑ Running Pandoc with ${#PANDOC_CMD[@]} arguments..."
          
          # Execute Pandoc with timeout
          if ! timeout $BUILD_TIMEOUT "${PANDOC_CMD[@]}"; then
            echo "::error::‚ùå E-book generation timed out after $BUILD_TIMEOUT seconds"
            exit 1
          fi
          
          # Verify output
          if [ ! -f "./output/${CONTENT_ID}.epub" ]; then
            echo "::error::‚ùå Failed to generate e-book: Output file not found"
            exit 1
          fi
          
          # Get file size
          FILESIZE=$(stat -c "%s" "./output/${CONTENT_ID}.epub" 2>/dev/null || stat -f "%z" "./output/${CONTENT_ID}.epub")
          echo "‚úÖ E-book generated successfully: ${CONTENT_ID}.epub (${FILESIZE} bytes)"
          echo "::set-output name=filename::${CONTENT_ID}.epub"
          echo "::set-output name=filesize::${FILESIZE}"

      - name: Upload E-Book Artifact
        uses: actions/upload-artifact@v4
        with:
          name: e-book-output
          path: ./output/${{ github.event.inputs.content_id }}.epub
          retention-days: 7
          compression-level: 9
          if-no-files-found: error
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Upload Debug Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-files
          path: |
            ./book-content/**/*
            ./*.log
            ./*.txt
          retention-days: 1
          compression-level: 6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Debug Output
        if: always()
        run: |
          echo "üîç Debugging information:"
          echo "Current directory: $(pwd)"
          echo "Output directory contents:"
          ls -la ./output/ || echo "Output directory not found"
          echo "Book content directory contents:"
          ls -la ./book-content/ || echo "Book content directory not found"
          
          # Check if the output directory exists
          if [ ! -d "./output" ]; then
            echo "::error::‚ùå Output directory does not exist"
            exit 1
          fi
          
          # Check for any error logs
          if [ -f "pandoc.log" ]; then
            echo "üìù Pandoc log contents:"
            cat pandoc.log
          fi
          
          # Check for the specific file
          EPUB_FILE="./output/${{ github.event.inputs.content_id }}.epub"
          if [ -f "$EPUB_FILE" ]; then
            FILESIZE=$(stat -c "%s" "$EPUB_FILE" 2>/dev/null || stat -f "%z" "$EPUB_FILE")
            echo "‚úÖ E-book generated successfully: $EPUB_FILE (${FILESIZE} bytes)"
            echo "::notice title=Success::E-book generated successfully!"
          else
            echo "::error::‚ùå E-book generation failed: $EPUB_FILE not found"
            echo "::error::Please check the previous steps for any errors"
            exit 1
          fi
