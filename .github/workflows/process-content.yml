name: Process and Publish E-Book

on:
  workflow_dispatch:
    inputs:
      content_id:
        description: 'Content ID for the book'
        required: true
        type: string
      format:
        description: 'Output format (epub, mobi, pdf, html, docx)'
        required: true
        default: 'epub'
        type: string
      metadata:
        description: 'Additional metadata as JSON string'
        required: false
        default: '{}'
        type: string

env:
  NEXT_PUBLIC_APP_URL: ${{ vars.NEXT_PUBLIC_APP_URL || 'https://matbu.vercel.app' }}
  NODE_ENV: production
  # Clerk JWT configuration - Production values
  JWT_ISSUER: 'clerk.clerko.v1'
  JWT_AUDIENCE: 'https://api.clerko.com'
  # Clerk template name and key ID
  CLERK_KEY_ID: 'jtmp_310Eh03rhbpy3wXWHcIaNkwwTpj'
  JWT_TEMPLATE: 'matbuapp'
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
  PRIVATE_KEY_B64: ${{ secrets.PRIVATE_KEY_B64 }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GITHUB_REPO_OWNER: bilgisen
  GITHUB_REPO_NAME: clerk
  # Timeouts in seconds
  DOWNLOAD_TIMEOUT: 300
  BUILD_TIMEOUT: 600

jobs:
  build-epub:
    name: Build EPUB
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm install --legacy-peer-deps
          npm install jose

      - name: Install system tools
        run: |
          echo "🔄 Updating package lists..."
          sudo apt-get update -qq
          
          echo "📦 Installing required tools..."
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
            pandoc \
            texlive-xetex \
            texlive-fonts-recommended \
            texlive-latex-recommended \
            jq \
            wget \
            parallel \
            curl \
            ca-certificates \
            gnupg \
            software-properties-common
            
          # Clean up to reduce image size
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*

      - name: Set up security files
        run: |
          echo "🔐 Setting up security files..."
          # Create .env file for the application
          echo "NEXT_PUBLIC_APP_URL=$NEXT_PUBLIC_APP_URL" > .env
          echo "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=$NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY" >> .env
          
          # Decode private key if provided
          if [ -n "$PRIVATE_KEY_B64" ]; then
            echo "🔑 Decoding private key..."
            echo "$PRIVATE_KEY_B64" | base64 --decode > private.pem
            chmod 600 private.pem
          else
            echo "⚠️ No private key provided, some features may be limited"
          fi
          
          # Set secure permissions
          chmod -R 700 .

      - name: Generate JWT Token
        id: generate-token
        timeout-minutes: 5
        env:
          PRIVATE_KEY_B64: ${{ secrets.PRIVATE_KEY_B64 }}
          JWT_ISSUER: 'clerk.clerko.v1'  # Hardcoded to match API expectations
          JWT_AUDIENCE: 'https://api.clerko.com'  # Hardcoded to match API expectations
          CLERK_KEY_ID: ${{ env.CLERK_KEY_ID }}
          JWT_TEMPLATE: 'matbuapp'  # Hardcoded template name
          NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}
          NODE_OPTIONS: --no-warnings
        run: |
          set -e
          echo "🔑 Generating JWT token..."
          
          # Create private key file from base64
          echo "$PRIVATE_KEY_B64" | base64 -d > private.pem
          chmod 600 private.pem
          
          # Verify private key was created
          if [ ! -f "private.pem" ]; then
            echo "::error::Failed to create private key file"
            exit 1
          fi
          
          # Install required dependencies
          npm install jose@^4.14.0
          
          # Make sure the script is executable
          chmod +x scripts/generate-jwt.mjs
          
          # Debug: Print environment variables
          echo "=== Environment Variables ==="
          echo "JWT_ISSUER: $JWT_ISSUER"
          echo "JWT_AUDIENCE: $JWT_AUDIENCE"
          echo "CLERK_KEY_ID: $CLERK_KEY_ID"
          echo "JWT_TEMPLATE: $JWT_TEMPLATE"
          
          # Generate the token with the private key and required env vars
          if ! JWT_TOKEN=$(PRIVATE_KEY_PATH=./private.pem \
            JWT_ISSUER="$JWT_ISSUER" \
            JWT_AUDIENCE="$JWT_AUDIENCE" \
            CLERK_KEY_ID="$CLERK_KEY_ID" \
            JWT_TEMPLATE="$JWT_TEMPLATE" \
            node scripts/generate-jwt.mjs 2>&1); then
            echo "::error::Failed to generate JWT token"
            exit 1
          fi
          
          # Verify the token is not empty
          if [ -z "$JWT_TOKEN" ]; then
            echo "::error::Generated JWT token is empty"
            exit 1
          fi
          
          # Set the JWT token and header in environment variables
          echo "JWT_TOKEN=$JWT_TOKEN" >> $GITHUB_ENV
          echo "JWT_HEADER=Bearer $JWT_TOKEN" >> $GITHUB_ENV
          
          # Debug: Print token info
          echo "=== JWT Token Info ==="
          echo "Token length: ${#JWT_TOKEN} characters"
          if command -v jq &> /dev/null; then
            echo -n "Token payload: "
            echo "$JWT_TOKEN" | cut -d'.' -f2 | base64 -d 2>/dev/null | jq -c '{iss, aud, sub, iat, exp}' || echo "Failed to decode JWT payload"
          fi
          
          # Clean up the private key
          rm -f private.pem
          
          echo "✅ JWT token generated successfully"

      - name: Debug JWT Token
        run: |
          echo "🔑 JWT Token Debug:"
          echo "Token length: ${#JWT_TOKEN}"
          echo "Header: ${JWT_HEADER:0:20}..."
          echo "Content ID: ${{ github.event.inputs.content_id }}"
          echo "Base URL: ${{ env.NEXT_PUBLIC_APP_URL }}"
          
          # Print the first part of the token for debugging (header)
          if [ -n "$JWT_TOKEN" ]; then
            echo "\nToken Header (decoded):"
            echo "$JWT_TOKEN" | cut -d'.' -f1 | base64 -d 2>/dev/null || echo "Failed to decode token header"
            
            echo "\nToken Payload (decoded):"
            echo "$JWT_TOKEN" | cut -d'.' -f2 | base64 -d 2>/dev/null || echo "Failed to decode token payload"
          else
            echo "\n❌ JWT_TOKEN is empty"
          fi

      - name: Fetch Book Content
        id: fetch-book
        timeout-minutes: 30
        env:
          CONTENT_ID: ${{ github.event.inputs.content_id }}
          BASE_URL: ${{ env.NEXT_PUBLIC_APP_URL }}
          JWT_HEADER: ${{ env.JWT_HEADER }}
          JWT_TOKEN: ${{ env.JWT_TOKEN }}
          DOWNLOAD_TIMEOUT: ${{ env.DOWNLOAD_TIMEOUT }}
          # Add verbose logging
          CURL_VERBOSE: "1"
          DEBUG: "*"
        run: |
          set -e
          echo "📚 Starting book content fetch for ID: $CONTENT_ID"
          
          # Debug environment variables (excluding sensitive data)
          echo "[INFO] 🔧 Environment variables:"
          printenv | grep -v -E 'SECRET|TOKEN|PASSWORD|KEY' | sort
          
          # Validate JWT token
          if [ -z "$JWT_TOKEN" ]; then
            echo "::error::JWT_TOKEN is empty"
            exit 1
          fi
          
          # Create output directory
          mkdir -p ./book-content
          
          # Make the script executable
          chmod +x scripts/fetch-book.sh
          
          # Debug: Print token info
          echo "[DEBUG] 🔑 JWT Token Info:"
          echo "- Token length: ${#JWT_TOKEN} characters"
          if command -v jq &> /dev/null; then
            echo -n "- Token payload: "
            echo "$JWT_TOKEN" | cut -d'.' -f2 | base64 -d 2>/dev/null | jq -c '{iss, aud, sub, iat, exp}' || echo "Failed to decode JWT payload"
          fi
          
          # Debug: Make a test request to the API
          echo "[DEBUG] 🧪 Testing API access..."
          curl -v -s -f \
            -H "Accept: application/json" \
            -H "Authorization: Bearer $JWT_TOKEN" \
            "$BASE_URL/api/books/by-id/$CONTENT_ID/payload" \
            -o /dev/null \
            -w "\nResponse Code: %{http_code}\n" \
            --max-time 30 || true
          
          # Set executable permissions and run the fetch script with timeout
          echo "[INFO] 🚀 Starting fetch-book.sh..."
          chmod +x ./scripts/fetch-book.sh
          
          # Execute the script with the token
          if ! timeout $DOWNLOAD_TIMEOUT ./scripts/fetch-book.sh; then
            echo "::error::Book content fetch failed"
            
            # Check for any error logs
            if [ -f "./curl-debug.log" ]; then
              echo "=== cURL Debug Log ==="
              cat ./curl-debug.log
            fi
            
            if [ -f "./headers.txt" ]; then
              echo "=== Response Headers ==="
              cat ./headers.txt
            fi
            
            exit 1
          fi
          
          echo "✅ Successfully fetched book content"
          
          # Extract metadata from the downloaded content
          if [ -f "./book-content/payload.json" ]; then
            echo "📋 Extracting metadata from payload..."
            jq '{ 
              title: .book.title, 
              author: .book.author, 
              language: .book.language,
              generateToc: (.options.generate_toc // true),
              tocDepth: (.options.toc_depth // 2),
              includeImprint: (.options.include_imprint // true)
            }' ./book-content/payload.json > ./book-metadata.json
            
            # Set output variables
            echo "::set-output name=title::$(jq -r '.title // "Untitled"' ./book-metadata.json)"
            echo "::set-output name=author::$(jq -r '.author // "Unknown"' ./book-metadata.json)"
            echo "::set-output name=language::$(jq -r '.language // "tr"' ./book-metadata.json)
            echo "::set-output name=generate_toc::$(jq -r '.generateToc // true' ./book-metadata.json)"
            echo "::set-output name=toc_depth::$(jq -r '.tocDepth // 2' ./book-metadata.json)
          else
            echo "::warning::⚠️ No payload.json found, using default metadata"
            echo "::set-output name=title::Untitled"
            echo "::set-output name=author::Unknown"
            echo "::set-output name=language::tr"
            echo "::set-output name=generate_toc::true"
            echo "::set-output name=toc_depth::2"
          fi
      
      - name: Generate E-Book
        id: generate-ebook
        timeout-minutes: 30
        env:
          BUILD_TIMEOUT: ${{ env.BUILD_TIMEOUT }}
        run: |
          set -e
          echo "📖 Starting e-book generation..."
          
          # Get metadata from previous step
          TITLE="${{ steps.fetch-book.outputs.title }}"
          AUTHOR="${{ steps.fetch-book.outputs.author }}"
          LANGUAGE="${{ steps.fetch-book.outputs.language }}"
          GENERATE_TOC="${{ steps.fetch-book.outputs.generate_toc }}"
          TOC_DEPTH="${{ steps.fetch-book.outputs.toc_depth }}"
          CONTENT_ID="${{ github.event.inputs.content_id }}"
          
          echo "📚 Book: $TITLE by $AUTHOR"
          echo "🌐 Language: $LANGUAGE"
          echo "📑 TOC: $GENERATE_TOC (Depth: $TOC_DEPTH)"
          
          # Prepare output directory
          mkdir -p ./output
          
          # Build Pandoc command
          PANDOC_CMD=(
            "pandoc"
            "--from=html"
            "--to=epub3"
            "--output=./output/${CONTENT_ID}.epub"
            "--epub-chapter-level=1"
            "--metadata=title:${TITLE}"
            "--metadata=author:${AUTHOR}"
            "--metadata=language:${LANGUAGE}"
            "--metadata=identifier:${CONTENT_ID}"
          )
          
          # Add TOC if enabled
          if [ "$GENERATE_TOC" = "true" ]; then
            PANDOC_CMD+=("--toc" "--toc-depth=${TOC_DEPTH}")
          fi
          
          # Add cover image if exists
          if [ -f "./book-content/cover.jpg" ]; then
            PANDOC_CMD+=("--epub-cover-image=./book-content/cover.jpg")
          fi
          
          # Add stylesheet if exists
          if [ -f "./book-content/styles/epub.css" ]; then
            PANDOC_CMD+=("--css=./book-content/styles/epub.css")
          fi
          
          # Add all chapter files in order
          while IFS= read -r -d $'\0' file; do
            PANDOC_CMD+=("$file")
          done < <(find ./book-content -type f -name 'chapter-*.xhtml' -print0 | sort -z -V)
          
          # Add imprint if exists
          if [ -f "./book-content/imprint.xhtml" ]; then
            PANDOC_CMD+=("./book-content/imprint.xhtml")
          fi
          
          echo "🔄 Running Pandoc with ${#PANDOC_CMD[@]} arguments..."
          
          # Execute Pandoc with timeout
          if ! timeout $BUILD_TIMEOUT "${PANDOC_CMD[@]}"; then
            echo "::error::❌ E-book generation timed out after $BUILD_TIMEOUT seconds"
            exit 1
          fi
          
          # Verify output
          if [ ! -f "./output/${CONTENT_ID}.epub" ]; then
            echo "::error::❌ Failed to generate e-book: Output file not found"
            exit 1
          fi
          
          # Get file size
          FILESIZE=$(stat -c "%s" "./output/${CONTENT_ID}.epub" 2>/dev/null || stat -f "%z" "./output/${CONTENT_ID}.epub")
          echo "✅ E-book generated successfully: ${CONTENT_ID}.epub (${FILESIZE} bytes)"
          echo "::set-output name=filename::${CONTENT_ID}.epub"
          echo "::set-output name=filesize::${FILESIZE}"

      - name: Upload E-Book Artifact
        uses: actions/upload-artifact@v4
        with:
          name: e-book-output
          path: ./output/${{ github.event.inputs.content_id }}.epub
          retention-days: 7
          compression-level: 9
          if-no-files-found: error
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Upload Debug Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-files
          path: |
            ./book-content/**/*
            ./*.log
            ./*.txt
          retention-days: 1
          compression-level: 6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Debug Output
        if: always()
        run: |
          echo "🔍 Debugging information:"
          echo "Current directory: $(pwd)"
          echo "Output directory contents:"
          ls -la ./output/ || echo "Output directory not found"
          echo "Book content directory contents:"
          ls -la ./book-content/ || echo "Book content directory not found"
          
          # Check if the output directory exists
          if [ ! -d "./output" ]; then
            echo "::error::❌ Output directory does not exist"
            exit 1
          fi
          
          # Check for any error logs
          if [ -f "pandoc.log" ]; then
            echo "📝 Pandoc log contents:"
            cat pandoc.log
          fi
          
          # Check for the specific file
          EPUB_FILE="./output/${{ github.event.inputs.content_id }}.epub"
          if [ -f "$EPUB_FILE" ]; then
            FILESIZE=$(stat -c "%s" "$EPUB_FILE" 2>/dev/null || stat -f "%z" "$EPUB_FILE")
            echo "✅ E-book generated successfully: $EPUB_FILE (${FILESIZE} bytes)"
            echo "::notice title=Success::E-book generated successfully!"
          else
            echo "::error::❌ E-book generation failed: $EPUB_FILE not found"
            echo "::error::Please check the previous steps for any errors"
            exit 1
          fi
