name: Process and Publish E-Book

on:
  workflow_dispatch:
    inputs:
      content_id:
        description: 'Content ID for the book'
        required: true
        type: string
      format:
        description: 'Output format (epub, mobi, pdf, html, docx)'
        required: true
        default: 'epub'
        type: string
      metadata:
        description: 'Additional metadata as JSON string'
        required: false
        default: '{}'
        type: string

env:
  # Environment configuration
  NODE_ENV: development  # Development mode for Clerk integration
  
  # Clerk JWT configuration - Development environment
  JWT_ISSUER: 'https://sunny-dogfish-14.clerk.accounts.dev'
  JWT_AUDIENCE: 'https://sunny-dogfish-14.clerk.accounts.dev'
  
  # Clerk template name and key ID - Using the key ID from Clerk's JWKS
  CLERK_KEY_ID: 'ins_2yhHfvuC7eV6d8wuj44hPANY5Kq'
  JWT_TEMPLATE: 'matbuapp'
  
  # Repository information
  GITHUB_REPO_OWNER: bilgisen
  GITHUB_REPO_NAME: clerk
  
  # Timeouts in seconds
  DOWNLOAD_TIMEOUT: 300
  BUILD_TIMEOUT: 600

jobs:
  build-epub:
    name: Build EPUB
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install dependencies
        run: |
          # Ensure we're using the correct Node.js version
          node --version
          npm --version
          
          # Install dependencies
          npm install --legacy-peer-deps
          npm install jose@^4.14.0

      - name: Install system tools
        run: |
          echo "üîÑ Updating package lists..."
          sudo apt-get update -qq
          
          echo "üì¶ Installing required tools..."
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
            coreutils \
            pandoc \
            texlive-xetex \
            texlive-fonts-recommended \
            texlive-latex-recommended \
            jq \
            wget \
            parallel \
            curl \
            ca-certificates \
            gnupg \
            software-properties-common
            
          # Verify coreutils is installed and base64 is available
          if ! command -v base64 &> /dev/null; then
            echo "::warning::base64 command not found in PATH, checking /usr/bin/"
            if [ -x "/usr/bin/base64" ]; then
              echo "Found base64 in /usr/bin/, adding to PATH"
              echo "/usr/bin" >> $GITHUB_PATH
              export PATH="/usr/bin:$PATH"
            else
              echo "::error::base64 command not found after coreutils installation"
              exit 1
            fi
          fi
          
          # Verify base64 works
          if ! echo "test" | base64 > /dev/null 2>&1; then
            echo "::error::base64 command is not working as expected"
            exit 1
          fi
          
          # Clean up to reduce image size
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*

      - name: Set up security files
        run: |
          echo "üîê Setting up security files..."
          # Create .env file for the application
          echo "NEXT_PUBLIC_APP_URL=https://matbu.vercel.app" > .env
          echo "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=$NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY" >> .env
          
          # Set secure permissions
          chmod -R 700 .

      - name: Generate JWT Token
        id: generate_jwt
        env:
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          PRIVATE_KEY_B64: ${{ secrets.PRIVATE_KEY_B64 }}
          JWT_ISSUER: ${{ env.JWT_ISSUER || 'https://sunny-dogfish-14.clerk.accounts.dev' }}
          JWT_AUDIENCE: ${{ env.JWT_AUDIENCE || 'https://sunny-dogfish-14.clerk.accounts.dev' }}
          CLERK_KEY_ID: ${{ env.CLERK_KEY_ID || 'ins_2yhHfvuC7eV6d8wuj44hPANY5Kq' }}
          JWT_TEMPLATE: ${{ env.JWT_TEMPLATE || 'matbuapp' }}
          NEXT_PUBLIC_APP_URL: 'https://matbu.vercel.app'
          
          # Additional context for debugging
          NODE_OPTIONS: --no-warnings
          NODE_DEBUG: jose
          DEBUG: '*'
          
          # GitHub context
          GITHUB_WORKFLOW: ${{ github.workflow }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_ACTION: ${{ github.action }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -e
          echo "üîë Generating JWT token..."
          
          # Create a temporary directory for our files
          TEMP_DIR=$(mktemp -d)
          trap 'rm -rf "$TEMP_DIR"' EXIT
          
          # Create private key file from base64
          if [ -z "$PRIVATE_KEY_B64" ]; then
            echo "‚ùå PRIVATE_KEY_B64 is not set"
            exit 1
          fi
          
          # Write the base64-decoded private key to file
          echo "$PRIVATE_KEY_B64" | base64 --decode > "$TEMP_DIR/private.pem"
          chmod 600 "$TEMP_DIR/private.pem"
          
          # Verify the key format
          if ! grep -q 'BEGIN PRIVATE KEY' "$TEMP_DIR/private.pem" && ! grep -q 'BEGIN RSA PRIVATE KEY' "$TEMP_DIR/private.pem"; then
            echo "‚ùå Invalid private key format. Expected PEM format with BEGIN PRIVATE KEY or BEGIN RSA PRIVATE KEY"
            echo "First 100 chars of key:"
            head -c 100 "$TEMP_DIR/private.pem"
            exit 1
          fi
          
          echo '‚úÖ Private key file created with proper permissions'
          
          # Install required dependencies
          echo "üì¶ Installing dependencies..."
          npm install jose@^4.14.0
          
          # Debug: Print environment variables
          echo "\n=== Environment Variables ==="
          echo "JWT_ISSUER: $JWT_ISSUER"
          echo "JWT_AUDIENCE: $JWT_AUDIENCE"
          echo "CLERK_KEY_ID: $CLERK_KEY_ID"
          echo "JWT_TEMPLATE: $JWT_TEMPLATE"
          
          # Generate the token with the private key and required env vars
          echo "\nüî® Generating JWT token..."
          
          # Debug: Print environment variables
          echo "=== Environment Variables ==="
          echo "JWT_ISSUER: $JWT_ISSUER"
          echo "JWT_AUDIENCE: $JWT_AUDIENCE"
          echo "CLERK_KEY_ID: $CLERK_KEY_ID"
          echo "JWT_TEMPLATE: $JWT_TEMPLATE"
          
          # Debug: Check if the key ID is being overridden
          echo "\n=== Checking Key ID in JWT Generation Script ==="
          if [ -f "scripts/generate-jwt.mjs" ]; then
            echo "Checking for key ID in generate-jwt.mjs:"
            grep -A 5 -B 5 "kid" scripts/generate-jwt.mjs || echo "No explicit key ID found in generate-jwt.mjs"
          fi
          
          # Ensure all required environment variables are set
          if [ -z "$JWT_ISSUER" ] || [ -z "$JWT_AUDIENCE" ] || [ -z "$CLERK_KEY_ID" ]; then
            echo "‚ùå Missing required environment variables"
            echo "JWT_ISSUER: $JWT_ISSUER"
            echo "JWT_AUDIENCE: $JWT_AUDIENCE"
            echo "CLERK_KEY_ID: $CLERK_KEY_ID"
            exit 1
          fi
          
          # Debug: Print the exact command we're about to run
          echo "\n=== Running JWT Generation ==="
          echo "node scripts/generate-jwt.mjs with environment:"
          echo "- PRIVATE_KEY_PATH=$TEMP_DIR/private.pem"
          echo "- JWT_ISSUER=$JWT_ISSUER"
          echo "- JWT_AUDIENCE=$JWT_AUDIENCE"
          echo "- CLERK_KEY_ID=$CLERK_KEY_ID"
          echo "- JWT_TEMPLATE=$JWT_TEMPLATE"
          
          # Debug: Print environment variables before running the script
          echo "\n=== Environment Variables in Workflow ==="
          echo "JWT_ISSUER: $JWT_ISSUER"
          echo "JWT_AUDIENCE: $JWT_AUDIENCE"
          echo "CLERK_KEY_ID: $CLERK_KEY_ID"
          echo "JWT_TEMPLATE: $JWT_TEMPLATE"
          
          # Run the script and capture all output
          set +e
          JWT_OUTPUT=$(PRIVATE_KEY_PATH="$TEMP_DIR/private.pem" \
            JWT_ISSUER="$JWT_ISSUER" \
            JWT_AUDIENCE="$JWT_AUDIENCE" \
            CLERK_KEY_ID="$CLERK_KEY_ID" \
            JWT_TEMPLATE="$JWT_TEMPLATE" \
            NODE_DEBUG=* \
            DEBUG=* \
            node scripts/generate-jwt.mjs 2>&1)
          
          # Capture the exit status
          JWT_EXIT_CODE=$?
          set -e
          
          # Save the full output to a file for debugging
          echo "$JWT_OUTPUT" > jwt-debug.log
          
          # Print the output (limited to avoid overwhelming logs)
          echo "=== JWT Generation Output (last 50 lines) ==="
          echo "$JWT_OUTPUT" | tail -n 50
          
          # Check if the command failed
          if [ $JWT_EXIT_CODE -ne 0 ]; then
            echo "::error::Failed to generate JWT token (exit code: $JWT_EXIT_CODE)"
            echo "::group::Full JWT Generation Output"
            echo "$JWT_OUTPUT"
            echo "::endgroup::"
            
            # Try to extract just the error message if possible
            ERROR_MSG=$(echo "$JWT_OUTPUT" | grep -i -E 'error|exception|failed' | tail -n 5 || true)
            if [ -n "$ERROR_MSG" ]; then
              echo "::error::Error details: $ERROR_MSG"
            fi
            
            exit 1
          fi
          
          # Read the token from the file
          # First try the current directory, then the workspace directory
          JWT_TOKEN_FILE="jwt-token.txt"
          WORKSPACE_TOKEN_FILE="$GITHUB_WORKSPACE/jwt-token.txt"
          
          # Check which token file exists
          if [ -f "$JWT_TOKEN_FILE" ]; then
            echo "Found JWT token in current directory"
            JWT_TOKEN=$(cat "$JWT_TOKEN_FILE" | tr -d '[:space:]')
          elif [ -f "$WORKSPACE_TOKEN_FILE" ]; then
            echo "Found JWT token in workspace directory"
            JWT_TOKEN=$(cat "$WORKSPACE_TOKEN_FILE" | tr -d '[:space:]')
          else
            echo "::error::JWT token file not found in current directory or workspace"
            echo "Current directory contents:"
            ls -la ./
            if [ -n "$GITHUB_WORKSPACE" ]; then
              echo "Workspace directory contents:"
              ls -la "$GITHUB_WORKSPACE/"
            fi
            exit 1
          fi
          
          # Verify we got a token
          if [ -z "$JWT_TOKEN" ] || [ $(echo "$JWT_TOKEN" | wc -c) -lt 100 ]; then
            echo "::error::Invalid or empty JWT token in file"
            echo "Token length: ${#JWT_TOKEN} characters"
            exit 1
          fi
          
          # Verify the token looks like a JWT (has two dots)
          DOT_COUNT=$(echo "$JWT_TOKEN" | tr -cd '.' | wc -c)
          if [ "$DOT_COUNT" -ne 2 ]; then
            echo "::error::Generated JWT token is invalid (expected 2 parts, got $DOT_COUNT)"
            echo "Token start: ${JWT_TOKEN:0:30}..."
            exit 1
          fi
          
          # Set the JWT token and header in environment variables
          echo "JWT_TOKEN=$JWT_TOKEN" >> $GITHUB_ENV
          echo "JWT_HEADER=Bearer $JWT_TOKEN" >> $GITHUB_ENV
          
          # Debug: Print token info using Node.js for base64 decoding
          echo "\n=== JWT Token Info ==="
          echo "Token length: ${#JWT_TOKEN} characters"
          
          # Decode and display token payload using Node.js
          node -e "
            try {
              const fs = require('fs');
              
              // Try to read the token from the file if not in env
              let token = process.env.JWT_TOKEN;
              if (!token) {
                try {
                  token = fs.readFileSync('jwt-token.txt', 'utf8').trim();
                  console.log('Read token from file');
                } catch (e) {
                  console.error('Error reading token from file:', e.message);
                }
              }
              
              if (!token) {
                throw new Error('No JWT token found in environment or file');
              }
              
              console.log('Token length:', token.length);
              
              // Split the token into parts
              const parts = token.split('.');
              if (parts.length !== 3) {
                throw new Error(`Invalid JWT format: expected 3 parts, got ${parts.length}`);
              }
              
              // Decode and log the token parts
              const [header, payload, signature] = parts;
              console.log('\nüîê JWT Header:');
              console.log(JSON.stringify(JSON.parse(Buffer.from(header, 'base64').toString('utf-8')), null, 2));
              
              console.log('\nüîê JWT Payload:');
              console.log(JSON.stringify(JSON.parse(Buffer.from(payload, 'base64').toString('utf-8')), null, 2));
              
              console.log('\nüîê JWT Signature (first 10 chars):', signature.substring(0, 10) + '...');
              console.log('\n‚úÖ Token decoded successfully');
              
            } catch (error) {
              console.error('Error decoding token:', error.message);
              console.error('Error stack:', error.stack);
              process.exit(1);
            }
          "
          
          echo "\n‚úÖ JWT token generated and environment variables set"

      - name: Debug JWT Token
        run: |
          echo "üîë JWT Token Debug:"
          echo "Token length: ${#JWT_TOKEN}"
          echo "Header: ${JWT_HEADER:0:20}..."
          echo "Content ID: ${{ github.event.inputs.content_id }}"
          echo "Base URL: https://matbu.vercel.app"
          echo "Repository: ${{ env.GITHUB_REPO_OWNER }}/${{ env.GITHUB_REPO_NAME }}"
          
          # Print the first part of the token for debugging (header)
          if [ -n "$JWT_TOKEN" ]; then
            echo "\nToken Header (decoded):"
            echo "$JWT_TOKEN" | cut -d'.' -f1 | base64 -d 2>/dev/null || echo "Failed to decode token header"
            
            echo "\nToken Payload (decoded):"
            echo "$JWT_TOKEN" | cut -d'.' -f2 | base64 -d 2>/dev/null || echo "Failed to decode token payload"
          else
            echo "\n‚ùå JWT_TOKEN is empty"
          fi

      - name: Fetch Book Content
        id: fetch-book
        timeout-minutes: 30
        env:
          CONTENT_ID: ${{ github.event.inputs.content_id }}
          BASE_URL: 'https://matbu.vercel.app'
          GITHUB_REPO_OWNER: ${{ env.GITHUB_REPO_OWNER }}
          GITHUB_REPO_NAME: ${{ env.GITHUB_REPO_NAME }}
          GITHUB_REF: ${{ github.ref }}
          JWT_HEADER: ${{ env.JWT_HEADER }}
          JWT_TOKEN: ${{ env.JWT_TOKEN }}
          DOWNLOAD_TIMEOUT: ${{ env.DOWNLOAD_TIMEOUT }}
          # Add verbose logging
          CURL_VERBOSE: "1"
          DEBUG: "*"
        run: |
          set -e
          echo "üìö Starting book content fetch for ID: $CONTENT_ID"
          
          # Debug environment variables (excluding sensitive data)
          echo "[INFO] üîß Environment variables:"
          printenv | grep -v -E 'SECRET|TOKEN|PASSWORD|KEY' | sort
          
          # Validate JWT token
          if [ -z "$JWT_TOKEN" ]; then
            echo "::error::JWT_TOKEN is empty"
            exit 1
          fi
          
          # Create output directory
          mkdir -p ./book-content
          
          # Make the script executable
          chmod +x scripts/fetch-book.sh
          
          # Debug: Print token info
          echo "[DEBUG] üîë JWT Token Info:"
          echo "- Token length: ${#JWT_TOKEN} characters"
          if command -v jq &> /dev/null; then
            echo -n "- Token payload: "
            echo "$JWT_TOKEN" | cut -d'.' -f2 | base64 -d 2>/dev/null | jq -c '{iss, aud, sub, iat, exp}' || echo "Failed to decode JWT payload"
          fi
          
          # Debug: Make a test request to the API
          echo "[DEBUG] üß™ Testing API access..."
          curl -v -s -f \
            -H "Accept: application/json" \
            -H "Authorization: Bearer $JWT_TOKEN" \
            "$BASE_URL/api/books/by-id/$CONTENT_ID/payload" \
            -o /dev/null \
            -w "\nResponse Code: %{http_code}\n" \
            --max-time 30 || true
          
          # Set executable permissions and run the fetch script with timeout
          echo "[INFO] üöÄ Starting fetch-book.sh..."
          chmod +x ./scripts/fetch-book.sh
          
          # Execute the script with the token
          if ! timeout $DOWNLOAD_TIMEOUT ./scripts/fetch-book.sh; then
            echo "::error::Book content fetch failed"
            
            # Check for any error logs
            if [ -f "./curl-debug.log" ]; then
              echo "=== cURL Debug Log ==="
              cat ./curl-debug.log
            fi
            
            if [ -f "./headers.txt" ]; then
              echo "=== Response Headers ==="
              cat ./headers.txt
            fi
            
            exit 1
          fi
          
          echo "‚úÖ Successfully fetched book content"
          
          # Extract metadata from the downloaded content
          if [ -f "./book-content/payload.json" ]; then
            echo "üìã Extracting metadata from payload..."
            jq '{ 
              title: .book.title, 
              author: .book.author, 
              language: .book.language,
              generateToc: (.options.generate_toc // true),
              tocDepth: (.options.toc_depth // 2),
              includeImprint: (.options.include_imprint // true)
            }' ./book-content/payload.json > ./book-metadata.json
            
            # Set output variables
            echo "::set-output name=title::$(jq -r '.title // "Untitled"' ./book-metadata.json)"
            echo "::set-output name=author::$(jq -r '.author // "Unknown"' ./book-metadata.json)"
            echo "::set-output name=language::$(jq -r '.language // "tr"' ./book-metadata.json)
            echo "::set-output name=generate_toc::$(jq -r '.generateToc // true' ./book-metadata.json)"
            echo "::set-output name=toc_depth::$(jq -r '.tocDepth // 2' ./book-metadata.json)
          else
            echo "::warning::‚ö†Ô∏è No payload.json found, using default metadata"
            echo "::set-output name=title::Untitled"
            echo "::set-output name=author::Unknown"
            echo "::set-output name=language::tr"
            echo "::set-output name=generate_toc::true"
            echo "::set-output name=toc_depth::2"
          fi
      
      - name: Prepare Directories
        run: |
          echo "üìÇ Preparing directories..."
          mkdir -p ./output
          mkdir -p ./book-content
          echo "‚úÖ Directories created successfully"
          echo "Current directory structure:"
          ls -la ./
          
      - name: Generate E-Book
        id: generate-ebook
        timeout-minutes: 30
        env:
          BUILD_TIMEOUT: ${{ env.BUILD_TIMEOUT }}
        run: |
          set -e
          echo "üìñ Starting e-book generation..."
          
          # Get metadata from previous step
          TITLE="${{ steps.fetch-book.outputs.title }}"
          AUTHOR="${{ steps.fetch-book.outputs.author }}"
          LANGUAGE="${{ steps.fetch-book.outputs.language }}"
          GENERATE_TOC="${{ steps.fetch-book.outputs.generate_toc }}"
          TOC_DEPTH="${{ steps.fetch-book.outputs.toc_depth }}"
          CONTENT_ID="${{ github.event.inputs.content_id }}"
          
          echo "üìö Book: $TITLE by $AUTHOR"
          echo "üåê Language: $LANGUAGE"
          echo "üìë TOC: $GENERATE_TOC (Depth: $TOC_DEPTH)"
          
          # Verify output directory exists
          if [ ! -d "./output" ]; then
            echo "::error::‚ùå Output directory does not exist"
            exit 1
          fi
          
          # Build Pandoc command
          PANDOC_CMD=(
            "pandoc"
            "--from=html"
            "--to=epub3"
            "--output=./output/${CONTENT_ID}.epub"
            "--epub-chapter-level=1"
            "--metadata=title:${TITLE}"
            "--metadata=author:${AUTHOR}"
            "--metadata=language:${LANGUAGE}"
            "--metadata=identifier:${CONTENT_ID}"
          )
          
          # Add TOC if enabled
          if [ "$GENERATE_TOC" = "true" ]; then
            PANDOC_CMD+=("--toc" "--toc-depth=${TOC_DEPTH}")
          fi
          
          # Add cover image if exists
          if [ -f "./book-content/cover.jpg" ]; then
            PANDOC_CMD+=("--epub-cover-image=./book-content/cover.jpg")
          fi
          
          # Add stylesheet if exists
          if [ -f "./book-content/styles/epub.css" ]; then
            PANDOC_CMD+=("--css=./book-content/styles/epub.css")
          fi
          
          # Add all chapter files in order
          while IFS= read -r -d $'\0' file; do
            PANDOC_CMD+=("$file")
          done < <(find ./book-content -type f -name 'chapter-*.xhtml' -print0 | sort -z -V)
          
          # Add imprint if exists
          if [ -f "./book-content/imprint.xhtml" ]; then
            PANDOC_CMD+=("./book-content/imprint.xhtml")
          fi
          
          echo "üîÑ Running Pandoc with ${#PANDOC_CMD[@]} arguments..."
          
          # Execute Pandoc with timeout
          if ! timeout $BUILD_TIMEOUT "${PANDOC_CMD[@]}"; then
            echo "::error::‚ùå E-book generation timed out after $BUILD_TIMEOUT seconds"
            exit 1
          fi
          
          # Verify output
          if [ ! -f "./output/${CONTENT_ID}.epub" ]; then
            echo "::error::‚ùå Failed to generate e-book: Output file not found"
            exit 1
          fi
          
          # Get file size
          FILESIZE=$(stat -c "%s" "./output/${CONTENT_ID}.epub" 2>/dev/null || stat -f "%z" "./output/${CONTENT_ID}.epub")
          echo "‚úÖ E-book generated successfully: ${CONTENT_ID}.epub (${FILESIZE} bytes)"
          echo "::set-output name=filename::${CONTENT_ID}.epub"
          echo "::set-output name=filesize::${FILESIZE}"

      - name: Upload E-Book Artifact
        uses: actions/upload-artifact@v4
        with:
          name: e-book-output
          path: ./output/${{ github.event.inputs.content_id }}.epub
          retention-days: 7
          compression-level: 9
          if-no-files-found: error
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Upload Debug Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-files
          path: |
            ./book-content/**/*
            ./*.log
            ./*.txt
          retention-days: 1
          compression-level: 6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Debug Output
        if: always()
        run: |
          echo "üîç Debugging information:"
          echo "Current directory: $(pwd)"
          
          # List all files in current directory for better debugging
          echo "üìÅ Current directory contents:"
          ls -la ./
          
          # Check for output directory
          if [ -d "./output" ]; then
            echo "üìÇ Output directory contents:"
            ls -la ./output/ || echo "Failed to list output directory"
          else
            echo "‚ö†Ô∏è Output directory does not exist"
            # Try to create it for future steps
            mkdir -p ./output
          fi
          
          # Check for book content directory
          if [ -d "./book-content" ]; then
            echo "üìö Book content directory contents:"
            ls -la ./book-content/ || echo "Failed to list book content directory"
          else
            echo "‚ö†Ô∏è Book content directory does not exist"
          fi
          
          # Check for any error logs
          if [ -f "pandoc.log" ]; then
            echo "üìù Pandoc log contents:"
            cat pandoc.log
          fi
          
          # Check for the specific file (using the content ID from inputs)
          CONTENT_ID="${{ github.event.inputs.content_id }}"
          EPUB_FILE="./output/${CONTENT_ID}.epub"
          
          if [ -f "$EPUB_FILE" ]; then
            FILESIZE=$(stat -c "%s" "$EPUB_FILE" 2>/dev/null || stat -f "%z" "$EPUB_FILE" 2>/dev/null || echo "unknown")
            echo "‚úÖ E-book generated successfully: $EPUB_FILE (${FILESIZE} bytes)"
            echo "::notice title=Success::E-book generated successfully!"
            echo "::set-output name=epub_path::$EPUB_FILE"
          else
            echo "::warning::‚ùå E-book not found: $EPUB_FILE"
            echo "Looking for any .epub files in output directory..."
            find ./output -name "*.epub" -exec echo "Found EPUB: {}" \;
            
            # Don't fail the step, just provide information
            # The actual build step will fail if there's a real issue
          fi
