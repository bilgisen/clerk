name: Build E-Book

on:
  workflow_dispatch:
    inputs:
      content_id:
        description: 'Content ID for the book'
        required: true
        type: string
      slug:
        description: 'Slug for the book'
        required: false
        type: string
      metadata:
        description: 'Additional metadata (optional)'
        required: false
        type: string

env:
  NODE_ENV: production
  API_BASE_URL: 'https://editor.bookshall.com'
  GITHUB_OIDC_AUDIENCE: 'https://editor.bookshall.com/api/ci'
  GHA_ALLOWED_REPO: '${{ github.repository }}'  # Only allow from this repository

jobs:
  build-epub:
    runs-on: ubuntu-latest
    permissions:
      id-token: write  # Required for OIDC token
      contents: read   # Required for checking out code
      actions: read    # Required for workflow run information
      
    # Environment variables for the job
    env:
      NODE_ENV: production
      API_BASE_URL: 'https://editor.bookshall.com'
      GITHUB_OIDC_AUDIENCE: 'https://editor.bookshall.com/api/ci'
      GHA_ALLOWED_REPO: ${{ github.repository }}
      GITHUB_REF_NAME: ${{ github.ref_name }}
      GITHUB_RUN_ID: ${{ github.run_id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install deps
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y curl jq

      - name: Get OIDC token
        id: get-oidc
        run: |
          echo "üîë Requesting OIDC token..."
          TOKEN_RESPONSE=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=$GITHUB_OIDC_AUDIENCE")
          
          if [ $? -ne 0 ]; then
            echo "::error::Failed to request OIDC token"
            exit 1
          fi
          
          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.value')
          
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
            echo "::error::Failed to obtain OIDC token"
            echo "Response: $TOKEN_RESPONSE"
            exit 1
          fi
          
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          
          # Debug: Print token info (without exposing the full token)
          echo "Token obtained successfully (length: ${#TOKEN} chars)"

      - name: Fetch book content
        env:
          # Required for the script
          CONTENT_ID: ${{ github.event.inputs.content_id }}
          GT_PAYLOAD_SECRET: ${{ secrets.GT_PAYLOAD_SECRET }}
          
          # Base URL for API requests
          BASE_URL: ${{ env.API_BASE_URL }}
          
          # Debug information
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF: ${{ github.ref }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          set -e
          echo "üîê Using secret token authentication"
          echo "Repository: $GITHUB_REPOSITORY"
          echo "Ref: $GITHUB_REF"
          echo "Run ID: $GITHUB_RUN_ID"
          
          # Debug: Print environment (without secrets)
          env | grep -v -E 'TOKEN|SECRET|PASSWORD|KEY' | sort
          
          mkdir -p ./book-content ./output
          chmod +x ./scripts/fetch-book.sh
          
          # Enable debug output if needed
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            export CURL_VERBOSE=1
          fi
          
          ./scripts/fetch-book.sh

      - name: Generate EPUB
        run: |
          CONTENT_ID="${{ github.event.inputs.content_id }}"
          TITLE=$(jq -r '.book.title // "Untitled"' ./book-content/payload.json)
          AUTHOR=$(jq -r '.book.author // "Unknown"' ./book-content/payload.json)
          LANGUAGE=$(jq -r '.book.language // "tr"' ./book-content/payload.json)

          PANDOC_CMD=(
            pandoc
            --from=html
            --to=epub3
            --output=./output/${CONTENT_ID}.epub
            --epub-chapter-level=1
            --metadata=title:"$TITLE"
            --metadata=author:"$AUTHOR"
            --metadata=language:"$LANGUAGE"
            --metadata=identifier:"$CONTENT_ID"
          )

          [ -f "./book-content/cover.jpg" ] && PANDOC_CMD+=(--epub-cover-image=./book-content/cover.jpg)
          [ -f "./book-content/styles/epub.css" ] && PANDOC_CMD+=(--css=./book-content/styles/epub.css)

          while IFS= read -r -d $'\0' file; do
            PANDOC_CMD+=("$file")
          done < <(find ./book-content -type f -name 'chapter-*.xhtml' -print0 | sort -z -V)

          [ -f "./book-content/imprint.xhtml" ] && PANDOC_CMD+=("./book-content/imprint.xhtml")

          echo "üìñ Building EPUB..."
          "${PANDOC_CMD[@]}"

      - name: Upload EPUB to Cloudflare R2
        run: |
          CONTENT_ID="${{ github.event.inputs.content_id }}"
          FILE_PATH="./output/${CONTENT_ID}.epub"
          RAW_SLUG="${{ github.event.inputs.slug }}"
          [ -z "$RAW_SLUG" ] && RAW_SLUG=$(jq -r '.book.title // "untitled"' ./book-content/payload.json)
          TL=$(printf "%s" "$RAW_SLUG" | iconv -f UTF-8 -t ASCII//TRANSLIT 2>/dev/null || echo "$RAW_SLUG")
          SLUG=$(echo "$TL" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g')
          [ -z "$SLUG" ] && SLUG="$CONTENT_ID"
          KEY="books/${SLUG}-${CONTENT_ID}.epub"

          echo "üöÄ Uploading to R2 as $KEY"
          npx --yes @aws-sdk/client-s3 node ./scripts/upload-epub-to-r2.mjs --file "$FILE_PATH" --key "$KEY"
