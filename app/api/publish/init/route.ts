import { NextResponse } from "next/server";
import { withClerkAuth } from "@/middleware/auth";
import { initializePublishSession } from '@/lib/publish/session-utils';
import { PublishStatus } from "@/lib/store/redis";
import { logger } from "@/lib/logger";
import type { NextRequest } from "next/server";

// Extend the NextRequest type to include our auth context
type AuthenticatedRequest = NextRequest & {
  authContext: {
    type: 'clerk';
    userId: string;
    email?: string;
    firstName?: string;
    lastName?: string;
  };
};

// POST /api/publish/init
// Protected by Clerk authentication
// Body: { contentId: string, metadata?: Record<string, unknown> }
export const dynamic = 'force-dynamic';

export interface InitPublishRequest {
  contentId: string;
  metadata?: Record<string, unknown>;
}

const handler = async (req: NextRequest) => {
  try {
    // The auth middleware ensures we have a valid Clerk context
    const authContext = (req as unknown as AuthenticatedRequest).authContext;
    const { userId } = authContext;
    
    logger.info('Initializing publish session', { userId });
    
    const { contentId, metadata } = await req.json() as InitPublishRequest;

    if (!contentId) {
      return NextResponse.json(
        { error: "Content ID is required", code: "VALIDATION_ERROR" },
        { status: 400 }
      );
    }

    logger.info('Initializing publish session', { userId, contentId });
    
    // Initialize a new publish session
    const session = await initializePublishSession({
      userId,
      contentId,
      metadata: {
        ...metadata,
        // Add auth context to metadata for audit
        authType: authContext.type,
        authTime: new Date().toISOString()
      },
      // Will be generated by initializePublishSession if not provided
      nonce: undefined,
      gh: undefined // Will be populated during GitHub OIDC attestation
    });
    
    if (!session) {
      logger.error('Failed to initialize publish session', { userId, contentId });
      throw new Error('Failed to initialize publish session');
    }
    
    logger.info('Publish session initialized', { 
      sessionId: session.id,
      contentId,
      status: session.status 
    });

    // Return the minimal required session data
    // Return only non-sensitive session data
    return NextResponse.json({
      sessionId: session.id,
      nonce: session.nonce, // Used for GitHub OIDC attestation
      contentId: session.contentId,
      status: session.status as PublishStatus,
      createdAt: new Date(session.createdAt).toISOString()
    });

  } catch (error) {
    console.error("Publish init error:", error);
    
    if (error instanceof Error) {
      return NextResponse.json(
        { 
          error: error.message || "Internal server error", 
          code: error.name || "INTERNAL_SERVER_ERROR" 
        },
        { status: 500 }
      );
    }
    
    return NextResponse.json(
      { 
        error: "Internal server error", 
        code: "INTERNAL_SERVER_ERROR" 
      },
      { status: 500 }
    );
  };
};

// Export the handler wrapped with Clerk authentication
export const POST = withClerkAuth(handler);
