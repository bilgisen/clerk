import { auth, clerkMiddleware } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { verifyToken, type JWTPayload } from '@/lib/auth';

// List of public paths that don't require authentication
const publicPaths = [
  // Root path
  /^\/$/,
  // Auth pages
  /^\/sign-in(\/.*)?$/,
  /^\/sign-up(\/.*)?$/,
  // API routes
  /^\/api\/webhooks(\/.*)?$/,
  // Static assets
  /^\/_next\/static(\/.*)?$/,
  /^\/_next\/image(\/.*)?$/,
  /^\/favicon\.ico$/,
  // Public files
  /^\/.*\.(jpg|jpeg|png|gif|ico|svg|css|js|woff|woff2|ttf|eot)$/i,
];

// Type for JWT payload
type JwtPayload = {
  sub?: string;
  metadata?: Record<string, unknown>;
  [key: string]: unknown;
};

/**
 * Check if a path is in the public paths list
 * @param pathname - The path to check
 * @returns boolean indicating if the path is public
 */
const isPublicPath = (pathname: string): boolean => {
  return publicPaths.some((regex) => regex.test(pathname));
};

/**
 * Check if a path is a protected API route
 * @param pathname - The path to check
 * @returns boolean indicating if the path is a protected API route
 */
const isProtectedApiPath = (pathname: string): boolean => {
  return (
    pathname.startsWith('/api/books/') ||
    pathname.startsWith('/api/protected')
  );
};

// Define the main middleware function
export default clerkMiddleware(async (auth, req) => {
  const { pathname, search } = req.nextUrl;
  const method = req.method;
  const fullUrl = `${pathname}${search}`;

  console.log(`\n[Middleware] ${method} ${fullUrl}`);
  console.log(`[Middleware] Path: ${pathname}`);
  
  // Log all headers for debugging
  console.log('[Middleware] Headers:', Object.fromEntries(req.headers.entries()));

  // Skip middleware for public paths
  if (isPublicPath(pathname)) {
    console.log(`[Middleware] Allowing public path: ${pathname}`);
    return NextResponse.next();
  }
  
  console.log(`[Middleware] Checking authentication for: ${pathname}`);

  // Skip auth in development if DISABLE_AUTH is set
  if (process.env.NODE_ENV === 'development' && process.env.DISABLE_AUTH === 'true') {
    console.warn('[Middleware] ⚠️ Auth is disabled in development mode');
    const requestHeaders = new Headers(req.headers);
    requestHeaders.set('x-user-id', 'dev-user-id');
    requestHeaders.set('x-auth-method', 'development');
    return NextResponse.next({ request: { headers: requestHeaders } });
  }

  // Handle protected API routes
  if (isProtectedApiPath(pathname)) {
    console.debug(`[Middleware] Processing protected API route: ${pathname}`);
    
    // Check for JWT token in Authorization header
    const authHeader = req.headers.get('authorization');
    if (authHeader?.startsWith('Bearer ')) {
      const token = authHeader.split(' ')[1];
      console.debug('[Middleware] JWT token found, verifying...');
      
      try {
        const jwtSecret = process.env.JWT_SECRET || process.env.CLERK_SECRET_KEY;
        
        if (!jwtSecret) {
          throw new Error('JWT_SECRET or CLERK_SECRET_KEY not configured');
        }
        
        // Verify JWT using the consolidated auth utility
        const decoded = await verifyToken(token, { 
          operation: 'middleware-auth' 
        });
        
        if (!decoded) {
          throw new Error('Failed to verify token');
        }
        
        // Use userId or sub as the user identifier
        const userId = decoded.userId || decoded.sub;
        if (!userId) {
          throw new Error('JWT token missing user identifier (sub or userId)');
        }
        
        console.debug(`[Middleware] JWT verified for user: ${userId}`);
        
        // Update request headers with user info
        const requestHeaders = new Headers(req.headers);
        requestHeaders.set('x-user-id', userId);
        requestHeaders.set('x-auth-method', 'jwt');
        
        if (decoded.metadata) {
          requestHeaders.set('x-auth-metadata', JSON.stringify(decoded.metadata));
        }
        
        // Create response with updated headers
        const response = NextResponse.next({ request: { headers: requestHeaders } });
        response.headers.set('x-auth-method', 'jwt');
        response.headers.set('x-auth-user-id', decoded.sub);
        
        return response;
      } catch (jwtError) {
        console.error('[Middleware] JWT verification failed:', jwtError);
        // Continue to try Clerk session if JWT verification fails
      }
    }
    
    // If no valid JWT token, try Clerk session
    try {
      console.log('[Middleware] Checking Clerk session...');
      const session = await auth();
      
      console.log('[Middleware] Session data:', {
        hasSession: !!session,
        userId: session?.userId,
        sessionId: session?.sessionId,
        sessionStatus: session?.sessionId ? 'active' : 'inactive'
      });
      
      if (!session?.userId) {
        console.warn('[Middleware] No active session found');
        
        // If we're already on the sign-in page, don't redirect again
        if (pathname.startsWith('/sign-in')) {
          console.log('[Middleware] Already on sign-in page, allowing access');
          return NextResponse.next();
        }
        
        // Redirect to sign-in with return URL
        const signInUrl = new URL('/sign-in', req.nextUrl.origin);
        signInUrl.searchParams.set('redirect_url', pathname);
        console.log(`[Middleware] Redirecting to sign-in: ${signInUrl.toString()}`);
        
        return NextResponse.redirect(signInUrl);
      }
      
      console.debug(`[Middleware] Authenticated via Clerk session: ${session.userId}`);
      
      // Update request headers with session info
      const requestHeaders = new Headers(req.headers);
      requestHeaders.set('x-user-id', session.userId);
      requestHeaders.set('x-auth-method', 'clerk-session');
      
      // Add email from session claims if available
      const email = session.sessionClaims?.email;
      if (email && typeof email === 'string') {
        requestHeaders.set('x-user-email', String(email));
      }

      // Create response with updated headers
      const response = NextResponse.next({ 
        request: { 
          headers: requestHeaders 
        } 
      });
      
      response.headers.set('x-auth-method', 'clerk-session');
      response.headers.set('x-auth-user-id', session.userId);
      
      return response;
    } catch (error) {
      console.error('[Middleware] Error verifying session:', error);
      return new NextResponse(
        JSON.stringify({
          error: 'Internal server error during authentication',
          status: 500,
          path: pathname
        }), 
        { 
          status: 500,
          headers: { 
            'Content-Type': 'application/json'
          } 
        }
      );
    }
  }

  return NextResponse.next();
});

// Configure which routes should be processed by the middleware
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones matching the public paths
     * This is more specific than the default to prevent matching static files
     * and other assets that should bypass the middleware
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp|css|js|woff|woff2|ttf|eot)$).*)',
    // Explicitly include paths that should be processed
    '/dashboard/:path*',
    '/api/:path*',
  ],
};
